/* Import the test classes */
Import("Animal.*")
Import("Barker")

Import("Lyte.Reflect.GetProperties")
Import("Lyte.Test.*")

/* Icky Math */
Factorial <- @(n) {
  If (n `<` 0, {
    Raise("Cannot compute the factorial of " `++` n)
  }, If (n `<=` 1, {
    1
  }, {
    n `*` Factorial(n `-` 1)
  }))
}

FactorialTests <- %{
  "Value for Zero": {
    AssertEquals("Factorial(0) should be 1", Factorial(0), 1)
  },
  "Value for One": {
    AssertEquals("Factorial(1) should be 1", Factorial(1), 1)
  },
  "Value for Six": {
    AssertEquals("Factorial(6) should be 720", Factorial(6), 720)
  },
  "Value for -1": {
    AssertRaises("Factorial(-1) should raise an error", "Cannot compute the factorial of -1", Factorial(-1))
  },
  "Will Fail": {
    Fail("This test is guaranteed to fail")
  }
}

Test(FactorialTests) -> testResults
For (GetProperties(testResults), @(test) {
  If (testResults[test] `==` "Success", {
    EchoLn("Test \"" `++` test `++` "\" Passed!")
  }, {
    EchoLn("Test \"" `++` test `++` "\" Failed, reason \"" `++` testResults[test] `++` "\"")
  })
})
EchoLn

/* Puppy Dogs*/
Instantiate(Animal.Dog, "Fido") -> fido
fido `MixWith` Barker
fido.addTrick("roll over")
fido.addTrick("play dead")
fido.doTricks()
fido.bark(10)

/* Kittehs */
Instantiate(Animal.Cat, "Garfield") -> garfield
garfield.attack(fido)
garfield.pet(5)

{ Raise("Some men just want to see the world burn") } -> errorRaiser

/* Exceptions */
Try(errorRaiser, @(error) {
  error.printStackTrace()
})

"A string separated by spaces" -> myString
myString.toUpperCase().split(" ") -> myWords
Finalize("myWords")

Until(myWords.empty?, {
  myWords.pop EchoLn
})

Try({Null -> myWords}, EchoLn)

For(%[0:4:16], @(i) {
  If(i `==` 16, {
    EchoLn(i)
  }, {
    Echo(i `++` " ")
  })
})

TestObj <- %{
  name: "Bob",
  changeName: {
    Apply -> newName
    Lyte.Core.If (@name `==` newName, {
      EchoLn("Nothing to change.")
    }, {
      newName -> @name
    })
    Lyte.Reflect.Get("@name")
  }
}

EchoLn(StdOut, TestObj.changeName("Jeff"))

EchoLn(Eval("2 `+` 2"))
EchoLn(Lyte Type?)

AnotherTest <- %{
  myString: "Hello",
  __toString: {
    @myString[@j @i * 1 +]
  }
}

getNumbers <- {
  2 1
}

getNumbers() -> [AnotherTest.i, AnotherTest.j]
EchoLn(AnotherTest)

%{1: "3"} -> meep
meep Lyte.JSON.ToJSON EchoLn
"Derp" #["length"] EchoLn #length EchoLn Pop

%["String " `++` "Concatenation", "and something..."] EchoLn

PotatoHolder <- %{
  <- potato: {
    Try(@actualPotato, @(e) {
      "no potatoes"
    })
  },
  -> potato: @(kind) {
    kind `++` " potato" -> @actualPotato
  }
}

EchoLn(PotatoHolder.potato)
"white" -> PotatoHolder.potato
EchoLn(PotatoHolder.potato)

/* OpenFile("test.lyte", "r") -> file
file.readLn -> line
Until(line Undefined?, {
  EchoLn(line)
  file.readLn -> line
})
file.close

%[262, 294, 330, 349, 392, 440, 494, 523] -> frequencies
%[5, 5, 6, 7, 7, 6, 5, 4, 3, 3, 4, 5, 5, 4, 4] -> notes
For(notes, @(note) { Lyte.System.Beep(frequencies[note], 500) }) */
